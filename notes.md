- write a lexer
- Define the grammar for our lisp like language
- parse the tokens generated by our lexer based on our grammar and spit out AST
- For S-expression like languages, the ast looks like:
    - Atom node (contains the token type and value)
    - List node (List of elements(atoms))
- Next we will build an evaluator that recursively evaluates our AST and produces output.
    - For example, Atom(1) should return 1
    - List([AtomNode(PLUS, +), AtomNode(NUMBER, 1), AtomNode(NUMBER, 2)]) should return 3


What is our language grammar?
---
```
<program>    ::= <expression>* 

<expression> ::= <atom>
               | <list>
               | "'" <expression>    ; shorthand for (quote <expression>)

<atom>       ::= <number> 
               | <string>
               | <identifier>

<list>       ::= "(" <expression>* ")"

<number>     ::= [+-]? <digit>+ [ "." <digit>+ ]?
<string>     ::= "\"" { any character except "\"" } "\""
<identifier> ::= <letter> { <letter> | <digit> | "_" | "-" }
<digit>      ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
<letter>     ::= "a" | "b" | ... | "z" | "A" | "B" | ... | "Z"
```